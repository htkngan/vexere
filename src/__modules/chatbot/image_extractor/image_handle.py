from paddleocr import PaddleOCR
import PIL
from PIL import Image
import re
import os
import sys
from datetime import datetime

# Import nlp_engine t·ª´ module cha
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))
from nlp_extractor.nlp_engine import get_intent_entities_from_text

class TicketImageExtractor:
    """Tr√≠ch xu·∫•t th√¥ng tin v√© t·ª´ h√¨nh ·∫£nh s·ª≠ d·ª•ng PaddleOCR"""
    
    def __init__(self, use_gpu=False):
        """Kh·ªüi t·∫°o OCR engine
        Args:
            use_gpu: S·ª≠ d·ª•ng GPU hay kh√¥ng (m·∫∑c ƒë·ªãnh False)
        """
        self.ocr = PaddleOCR(
            use_angle_cls=True,
            lang='vi'  # Ti·∫øng Vi·ªát
        )
        
        # Patterns ƒë·ªÉ nh·∫≠n di·ªán th√¥ng tin v√©
        self.ticket_patterns = {
            'ticket_code': [
                re.compile(r'[A-Z]{2,3}\d{6,}', re.I),
                re.compile(r'M√£ v√©[:\s]*([A-Z0-9]+)', re.I),
                re.compile(r'Booking[:\s]*([A-Z0-9]+)', re.I)
            ],
            'departure': [
                re.compile(r'T·ª´[:\s]*([\w\s]+?)(?:\s*-|\s*ƒë·∫øn)', re.I),
                re.compile(r'Kh·ªüi h√†nh[:\s]*([\w\s]+?)(?:\s*-|\s*ƒë·∫øn)', re.I),
                re.compile(r'ƒêi·ªÉm ƒëi[:\s]*([\w\s]+?)(?:\s*-|\s*ƒë·∫øn)', re.I)
            ],
            'destination': [
                re.compile(r'ƒê·∫øn[:\s]*([\w\s]+?)(?:\s|$)', re.I),
                re.compile(r'ƒêi·ªÉm ƒë·∫øn[:\s]*([\w\s]+?)(?:\s|$)', re.I),
                re.compile(r'-\s*([\w\s]+?)(?:\s|$)', re.I)
            ],
            'departure_time': [
                re.compile(r'Gi·ªù kh·ªüi h√†nh[:\s]*(\d{1,2}:\d{2})', re.I),
                re.compile(r'Kh·ªüi h√†nh[:\s]*(\d{1,2}:\d{2})', re.I),
                re.compile(r'(\d{1,2}:\d{2})', re.I)
            ],
            'departure_date': [
                re.compile(r'Ng√†y[:\s]*(\d{1,2}/\d{1,2}/\d{4})', re.I),
                re.compile(r'(\d{1,2}/\d{1,2}/\d{4})', re.I),
                re.compile(r'(\d{1,2}-\d{1,2}-\d{4})', re.I)
            ],
            'quantity': [
                re.compile(r'S·ªë v√©[:\s]*(\d+)', re.I),
                re.compile(r'S·ªë l∆∞·ª£ng[:\s]*(\d+)', re.I),
                re.compile(r'(\d+)\s*v√©', re.I)
            ],
            'passenger_name': [
                re.compile(r'H·ªç t√™n[:\s]*([\w\s]+?)(?:\s|$)', re.I),
                re.compile(r'T√™n[:\s]*([\w\s]+?)(?:\s|$)', re.I)
            ],
            'phone': [
                re.compile(r'SƒêT[:\s]*(\d{10,11})', re.I),
                re.compile(r'ƒêi·ªán tho·∫°i[:\s]*(\d{10,11})', re.I),
                re.compile(r'(\d{10,11})', re.I)
            ],
            'price': [
                re.compile(r'Gi√°[:\s]*([\d,\.]+)', re.I),
                re.compile(r'Th√†nh ti·ªÅn[:\s]*([\d,\.]+)', re.I),
                re.compile(r'([\d,\.]+)\s*VND', re.I)
            ]
        }
    
    def extract_text_from_image(self, image_path):
        """Tr√≠ch xu·∫•t text t·ª´ h√¨nh ·∫£nh
        Args:
            image_path: ƒê∆∞·ªùng d·∫´n t·ªõi file ·∫£nh
        Returns:
            list: Danh s√°ch c√°c d√≤ng text ƒë∆∞·ª£c OCR
        """
        try:
            # Ki·ªÉm tra file t·ªìn t·∫°i
            if not os.path.exists(image_path):
                raise FileNotFoundError(f"Kh√¥ng t√¨m th·∫•y file: {image_path}")
            
            # Th·ª±c hi·ªán OCR
            result = self.ocr.ocr(image_path, cls=True)
            
            # Tr√≠ch xu·∫•t text
            extracted_lines = []
            if result and result[0]:
                for line in result[0]:
                    if line and len(line) >= 2:
                        text = line[1][0]  # Text content
                        confidence = line[1][1]  # Confidence score
                        
                        # Ch·ªâ l·∫•y text c√≥ ƒë·ªô tin c·∫≠y >= 0.5
                        if confidence >= 0.5:
                            extracted_lines.append(text.strip())
            
            return extracted_lines
            
        except Exception as e:
            print(f"L·ªói khi OCR h√¨nh ·∫£nh: {str(e)}")
            return []
    
    def extract_ticket_info(self, image_path):
        """Tr√≠ch xu·∫•t th√¥ng tin v√© t·ª´ h√¨nh ·∫£nh
        Args:
            image_path: ƒê∆∞·ªùng d·∫´n t·ªõi file ·∫£nh v√©
        Returns:
            dict: Th√¥ng tin v√© ƒë∆∞·ª£c tr√≠ch xu·∫•t
        """
        # Tr√≠ch xu·∫•t text t·ª´ h√¨nh ·∫£nh
        text_lines = self.extract_text_from_image(image_path)
        
        if not text_lines:
            return {
                'success': False,
                'message': 'Kh√¥ng th·ªÉ ƒë·ªçc ƒë∆∞·ª£c text t·ª´ h√¨nh ·∫£nh',
                'data': {}
            }
        
        # Gh√©p t·∫•t c·∫£ text th√†nh m·ªôt chu·ªói
        full_text = ' '.join(text_lines)
        print(f"üìÑ Text tr√≠ch xu·∫•t ƒë∆∞·ª£c: {full_text}")
        
        # Tr√≠ch xu·∫•t th√¥ng tin theo pattern
        ticket_info = {}
        
        for info_type, patterns in self.ticket_patterns.items():
            for pattern in patterns:
                match = pattern.search(full_text)
                if match:
                    if match.groups():
                        ticket_info[info_type] = match.group(1).strip()
                    else:
                        ticket_info[info_type] = match.group().strip()
                    break
        
        # Chu·∫©n h√≥a d·ªØ li·ªáu
        ticket_info = self._normalize_ticket_info(ticket_info)
        
        # S·ª≠ d·ª•ng NLP engine ƒë·ªÉ tr√≠ch xu·∫•t th√™m th√¥ng tin
        nlp_result = get_intent_entities_from_text(full_text)
        
        # K·∫øt h·ª£p th√¥ng tin t·ª´ OCR v√† NLP
        final_info = self._merge_ocr_nlp_results(ticket_info, nlp_result)
        
        return {
            'success': True,
            'message': 'Tr√≠ch xu·∫•t th√¥ng tin v√© th√†nh c√¥ng',
            'data': final_info,
            'raw_text': text_lines,
            'nlp_analysis': nlp_result
        }
    
    def _normalize_ticket_info(self, info):
        """Chu·∫©n h√≥a th√¥ng tin v√©"""
        normalized = info.copy()
        
        # Chu·∫©n h√≥a t√™n th√†nh ph·ªë
        city_mapping = {
            'h√† n·ªôi': 'h√† n·ªôi',
            'ha noi': 'h√† n·ªôi',
            'hanoi': 'h√† n·ªôi',
            's√†i g√≤n': 's√†i g√≤n',
            'sai gon': 's√†i g√≤n',
            'h·ªì ch√≠ minh': 's√†i g√≤n',
            'ho chi minh': 's√†i g√≤n',
            'hcm': 's√†i g√≤n',
            'ƒë√† n·∫µng': 'ƒë√† n·∫µng',
            'da nang': 'ƒë√† n·∫µng',
            'danang': 'ƒë√† n·∫µng'
        }
        
        for field in ['departure', 'destination']:
            if field in normalized:
                city = normalized[field].lower().strip()
                for key, value in city_mapping.items():
                    if key in city:
                        normalized[field] = value
                        break
        
        # Chu·∫©n h√≥a th·ªùi gian
        if 'departure_time' in normalized:
            time_str = normalized['departure_time']
            # ƒê·∫£m b·∫£o format HH:MM
            if ':' in time_str:
                parts = time_str.split(':')
                if len(parts) == 2:
                    try:
                        hour = int(parts[0])
                        minute = int(parts[1])
                        normalized['departure_time'] = f"{hour:02d}:{minute:02d}"
                    except:
                        pass
        
        # Chu·∫©n h√≥a s·ªë l∆∞·ª£ng
        if 'quantity' in normalized:
            try:
                normalized['quantity'] = int(normalized['quantity'])
            except:
                normalized['quantity'] = 1
        
        return normalized
    
    def _merge_ocr_nlp_results(self, ocr_info, nlp_result):
        """K·∫øt h·ª£p k·∫øt qu·∫£ OCR v√† NLP"""
        merged = ocr_info.copy()
        
        # Th√™m th√¥ng tin t·ª´ NLP entities
        if nlp_result and 'entities' in nlp_result:
            for entity in nlp_result['entities']:
                entity_type = entity['entity']
                entity_value = entity['value']
                
                # Map NLP entities sang OCR fields
                if entity_type == 'departure' and 'departure' not in merged:
                    merged['departure'] = entity_value
                elif entity_type == 'destination' and 'destination' not in merged:
                    merged['destination'] = entity_value
                elif entity_type == 'time' and 'departure_time' not in merged:
                    merged['departure_time'] = entity_value
                elif entity_type == 'date' and 'departure_date' not in merged:
                    merged['departure_date'] = entity_value
                elif entity_type == 'quantity' and 'quantity' not in merged:
                    # Tr√≠ch xu·∫•t s·ªë t·ª´ "X v√©"
                    qty_match = re.search(r'(\d+)', entity_value)
                    if qty_match:
                        merged['quantity'] = int(qty_match.group(1))
                elif entity_type == 'ticket_code' and 'ticket_code' not in merged:
                    merged['ticket_code'] = entity_value
        
        # Th√™m intent t·ª´ NLP
        if nlp_result and 'intent' in nlp_result:
            merged['detected_intent'] = nlp_result['intent']
            merged['intent_confidence'] = nlp_result.get('confidence', 0.0)
        
        return merged
    
    def create_booking_text(self, ticket_info):
        """T·∫°o text m√¥ t·∫£ th√¥ng tin v√© ƒë·ªÉ s·ª≠ d·ª•ng v·ªõi conversation manager"""
        if not ticket_info or not ticket_info.get('success'):
            return "Kh√¥ng th·ªÉ ƒë·ªçc th√¥ng tin v√© t·ª´ h√¨nh ·∫£nh"
        
        data = ticket_info.get('data', {})
        
        # T·∫°o c√¢u m√¥ t·∫£ ƒë·∫ßy ƒë·ªß
        description_parts = []
        
        if 'departure' in data and 'destination' in data:
            description_parts.append(f"ƒë·∫∑t v√© t·ª´ {data['departure']} ƒë·∫øn {data['destination']}")
        
        if 'departure_time' in data:
            description_parts.append(f"l√∫c {data['departure_time']}")
        
        if 'departure_date' in data:
            description_parts.append(f"ng√†y {data['departure_date']}")
        
        if 'quantity' in data:
            description_parts.append(f"{data['quantity']} v√©")
        
        if 'ticket_code' in data:
            description_parts.append(f"m√£ v√© {data['ticket_code']}")
        
        return " ".join(description_parts)


def demo_ticket_extraction():
    """Demo function ƒë·ªÉ test OCR v√©"""
    extractor = TicketImageExtractor()
    
    # Test v·ªõi m·ªôt ·∫£nh v√© m·∫´u (n·∫øu c√≥)
    test_image_path = "test_ticket.jpg"
    
    if os.path.exists(test_image_path):
        print(f"üîç ƒêang x·ª≠ l√Ω ·∫£nh: {test_image_path}")
        result = extractor.extract_ticket_info(test_image_path)
        
        print("\nüìã K·∫øt qu·∫£ tr√≠ch xu·∫•t:")
        print(f"Th√†nh c√¥ng: {result['success']}")
        print(f"Th√¥ng ƒëi·ªáp: {result['message']}")
        
        if result['success']:
            print("\nüìÑ Th√¥ng tin v√©:")
            for key, value in result['data'].items():
                print(f"  {key}: {value}")
            
            print(f"\nü§ñ Text ƒë·ªÉ s·ª≠ d·ª•ng v·ªõi chatbot:")
            booking_text = extractor.create_booking_text(result)
            print(f"  {booking_text}")
            
            # Test v·ªõi NLP engine
            nlp_result = get_intent_entities_from_text(booking_text)
            print(f"\nüß† Ph√¢n t√≠ch NLP:")
            print(f"  Intent: {nlp_result['intent']}")
            print(f"  Entities: {nlp_result['entities']}")
    else:
        print(f"‚ùå Kh√¥ng t√¨m th·∫•y file test: {test_image_path}")
        print("üí° ƒê·ªÉ test, h√£y ƒë·∫∑t m·ªôt ·∫£nh v√© t√™n 'test_ticket.jpg' trong th∆∞ m·ª•c hi·ªán t·∫°i")


if __name__ == "__main__":
    demo_ticket_extraction()
